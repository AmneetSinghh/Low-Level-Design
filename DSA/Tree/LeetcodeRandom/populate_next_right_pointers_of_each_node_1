// dfs appraoch

void dfs(Node* root, vector<Node*> &level, int state){
        if(!root)return;
        dfs(root->left,level,state+1);
        dfs(root->right,level,state+1);
        if(level[state]->val == INT_MIN){
            level[state] = root;
        }
        else{
            level[state]->next = root;
            level[state] = root;
        }
    }
class Solution {
public:
    Node* connect(Node* root) {
        vector<Node*> level(14);
        for(int i=0;i<level.size();i++){
            level[i] = new Node(INT_MIN);
        }
        dfs(root,level,0);
        return root;
    }
};




// bfs appraoch

// now we have a skewed tree,not a perfect tree.
// bfs approach
class Solution {
    public Node connect(Node root) {
        if(root == null)
            return null;
        Queue<Node> q = new LinkedList<>();
        q.offer(root);
        while(!q.isEmpty()) {
            int size = q.size();
            for(int i = 0; i < size; i++) {
                Node cur = q.poll();
                if(i == size-1)
                    cur.next = null;
                else
                    cur.next = q.peek();
                if(cur.left != null)
                    q.offer(cur.left);
                if(cur.right != null)
                    q.offer(cur.right);
            }
        }
        return root;
    }
}



