// solution using recursion
// just the idea is first go to right then go to left.
// intuition is : before parent's left is previous to parent's right. and parent
// parent-> left   -> right    parent->right    this is it.
struct node {
  int data;
  struct node * left, * right;
};

class Solution {
  node * prev = NULL;
  public:
    void flatten(node * root) {
      if (root == NULL) return;

      flatten(root -> right);
      flatten(root -> left);

      root -> right = prev;
      root -> left = NULL;
      prev = root;
    }

};



// iterative code, just same as above,   just first make the links for the left.

class Solution {
  node * prev = NULL;
  public:
   void flatten(node * root) {
  if (root == NULL) return;
  stack < node * > st;
  st.push(root);
  while (!st.empty()) {
    node * cur = st.top();
    st.pop();

    if (cur -> right != NULL) {
      st.push(cur -> right);
    }
    if (cur -> left != NULL) {
      st.push(cur -> left);
    }
    if (!st.empty()) {
      cur -> right = st.top();
    }
    cur -> left = NULL;
  }

}
}






/// using moris traversal
class Solution {
  public:
   void flatten(node* root) {
    node* cur = root;
		while (cur!=NULL)
		{
			if(cur->left == NULL){
        cur = cur->right;
      }
			else {
				node* pre = cur->left;
				while(pre->right)// go to deep right.
				{
					pre = pre->right;
        }
        // no back link. just do the improvements. make left-> null.
				pre->right = cur->right;
				cur->right = cur->left;
				cur->left = NULL;
			}
		}
  }

};

/*
moris traversal vch apa backlink lande si from node's->left, de deep right -> node
// but  moris vch node's->left, de deep right -> node->right as apa back t ana ni, so node's->left, de deep right -> node->right->left = null,  so no come
*/