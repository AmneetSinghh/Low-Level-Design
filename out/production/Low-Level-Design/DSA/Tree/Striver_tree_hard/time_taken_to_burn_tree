// bfs 

// simple mark parent then do bfs, make visitd array reminder.


// dfs

//Distance Of Farthest Node

/*
The total time taken by the tree to burn completely will be equal to the distance 
of the farthest node from the start node in the tree. So we will find three values for each node. 
*/


// dfs solution
class Triplet
{
public:
    int five, gb, m;

    Triplet(int five, int gb, int m)
    {
        this->five = five;
        this->gb = gb;
        this->m = m;
    }
};
Triplet timeToBurnTreeHelper(BinaryTreeNode<int> *root, int start)
{
    if (root == NULL)
    {
        return Triplet(-1, 0, 0);
    }

    Triplet left = timeToBurnTreeHelper(root->left, start);
    Triplet right = timeToBurnTreeHelper(root->right, start);

    Triplet ans = Triplet(-1, 0, 0);

    // Node is the starting node
    if (root->data == start)
    {
        ans.five = 0;
        ans.gb = max(left.m, right.m);
    }
    
    // Starting Node is in left subtree
    else if (left.five>=0)// five is in the left.
    {
        ans.five = left.five +1;
        ans.gb = max(left.gb,max(right.gb,ans.five+right.m));
    }
    
    // Starting Node is in right subtree
    else if (right.five>=0)// five is in the left.
    {
        ans.five = right.five +1;
        ans.gb = max(left.gb,max(right.gb,ans.five+left.m));
    }
    
    ans.m = max(left.m, right.m)+1;
    return ans;
}

int timeToBurnTree(BinaryTreeNode<int> *root, int start)
{
    Triplet ans = timeToBurnTreeHelper(root, start);
    return ans.gb;
}